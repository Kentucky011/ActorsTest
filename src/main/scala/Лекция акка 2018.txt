 Classic Actor

 Actor это - асинхронный объект, который имеет приватное изменяемое состояние, очередь входящих сообщений(Mailbox),
 и логику обработки этих сообщений(behavior).
 вызов у актора происходит с помощью ! знака, как в Erlang: counter ! incr(n) или можно использовать tell:
 counter.tell(incr(n)).

 запрос делается со знаком ? : counter ? Get => Future[Int] либо можно использовать "ask": counter.ask(Get) => Future[Int]

 Актор не имеет прямых вызовов, все вызовы работают через сообщения.
 В модели акторов - логика моделируется взаимодействием акторов, путем обмена сообщениями.
 У актора обработка сообщений всегда строго последовательная. Акторы работают не зависимо друг от друга в разных потоках.
 Общение двух акторов так же всегда последовательно, т.е. очередь сообщений не перемешивается.

 Простой пример актора:

 class CounterActor extends Actor {
 import CounterActor._
 private var value: Long = 0 // State

 ovveride def receive = {    // behavior
    case Incr(n) => value += n
    case Get     => sender() ! value // или Status.Failure(ex)
    }
 }

 object CounterActor {      // protocol список сообщений который актор может принимать
    case class Incr(n: Long)
    case object Get
 }

 как может выглядеть простое приложение:

 object Main extends App {

 val system = ActorSystem("MySystem") // создание актор системы, обычно делается 1 раз на всё приложение
 val counterActor: ActorRef =                             // ActorRef - идентификатор Actor'a
    system.actorOf(Props[CounterActor], name = "Counter") // инициализация актора(хитрым механизмом?) Мы не общаемся с самим объектом, а взаимодействуем через внешний интерфейс

 counterActor.tell(Incr(1))
 println(Await.result(counterActor ? Get, 1.minutes))

 }

 В Akka Typed идентификатор актора ActorRef[Protocol]
 У актора приватное состояние, не только переменные. Актор может скрывать за собой внешние сущности:
  - RandomAccessFile(seek/read). // файл на диске, из которого можно читать из любого места.
  - Данные во внешнем хранилище.
  - и др.

 Между акторами нет разделения, изменяемое состояние + параллелизм = "Share nothing" архитектура.
 Каждый актор инкапсулирует набор изменяемых переменных и других сущностей, доступ к ним имеет только ОН и доступ строго последовательный.
 Это позволяет делать код болеее понятным и предсказуемым.

 Что можно отправлять актору в сообщениях?
  - Неизменяемые данные(case class, immutable списки, Map и подобные структуры)
  - Ссылки на акторы(ActorRef)
 НЕЛЬЗЯ передавать любые ИЗМЕНЯЕМЫЕ ОБЪЕКТЫ.

 Можно ли посылать функции?
  тут возникают разногласия:
  - Можно потому, что функции тоже неизменяемые.
  - Нельзя потому, что если в замыкании mutable структуры, и они могут быть зацепленны с собой случайно.
    И ещё это сомнительно с точки зрения модели акторов.

По итогу передавать можно, но нужно быть очень осторожным! Особенно с разными замыканиями.

 Можно ли посылать внешние объекты вроде БД, сокетов и т.п.?
  - Нельзя, это нарушение модели.
  - Но можно, в крайнем случае, если мы понимаем что мы делаем и зачем. Так делается только на "границе" между акторами и внешним миром.

 Хороший пример актора: классификатор с обучением.
 Но один актор на классификацию и обучение - это не эффективно.
 Поэтому можно пойти другим путем, создать актор для обучения, Get запрос для модели - нужна immutable модель или функция копирования.

 Еще одна из идей вокруг акторов это LOCATION TRANSPARENCY
 Акторы могут быть расположены в разных машинах или даже на разных серверах. Взаимодействие акторов по сети не похоже на RPC(Remote Procedure Call)
 Подход акторов скорее обратный, т.е.:
 В классическом RPC идея такая, что мы все удаленные вызовы делаем похожими на локальные.
 А в Акторах подход такой, что мы все локальные вызовы - делаем подобные удаленным.
 (То есть мы не пытаемся натянуть простую модель - на сложный мир, а работаем сразу со сложной моделью во всех случаях, даже простых)
 Асинхронная логика больше похожа на взаимодействие по сети, чем на цепочку вызовов в одном потоке.


